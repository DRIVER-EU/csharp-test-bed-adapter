// ------------------------------------------------------------------------------
// <auto-generated>
//    Generated by avrogen.exe, version 0.9.0.0
//    Changes to this file may cause incorrect behavior and will be lost if code
//    is regenerated
// </auto-generated>
// ------------------------------------------------------------------------------
namespace eu.driver.model.sim.support.aggr
{
	using System;
	using System.Collections.Generic;
	using System.Text;
	using Avro;
	using Avro.Specific;
	
	public partial class AggrArea : ISpecificRecord
	{
		public static Schema _SCHEMA = Avro.Schema.Parse(@"{""type"":""record"",""name"":""AggrArea"",""namespace"":""eu.driver.model.sim.support.aggr"",""fields"":[{""name"":""boundary"",""doc"":""Optional list of locations, creating an edge between every consecutive location in the list. An additional edge is created between the last location in the list and the first location in the list, closing of the area. The smallest shape created by this boundary defines the area"",""default"":null,""type"":[""null"",{""type"":""array"",""items"":{""type"":""record"",""name"":""Location"",""namespace"":""eu.driver.model.sim.support"",""fields"":[{""name"":""latitude"",""doc"":""In decimal degrees, ranging from [-90, 90] where 0 is the equator"",""type"":""double""},{""name"":""longitude"",""doc"":""In decimal degrees, ranging from (-180, 180] where 0 is the Prime Meridian (line going through the geographic north, Greenwich, and the geographic south)"",""type"":""double""},{""name"":""altitude"",""doc"":""Optional in meters, where 0 is the surface of the WGS84-based ellipsoid"",""default"":null,""type"":[""null"",""double""]}]}}]},{""name"":""name"",""doc"":""Optional name of the area"",""default"":null,""type"":[""null"",""string""]},{""name"":""tags"",""doc"":""Optional map containing area specific information: key – unique name of the specific property; value – value of that property"",""default"":null,""type"":[""null"",{""type"":""map"",""values"":""string""}]}]}");
		/// <summary>
		/// Optional list of locations, creating an edge between every consecutive location in the list. An additional edge is created between the last location in the list and the first location in the list, closing of the area. The smallest shape created by this boundary defines the area
		/// </summary>
		private IList<eu.driver.model.sim.support.Location> _boundary;
		/// <summary>
		/// Optional name of the area
		/// </summary>
		private string _name;
		/// <summary>
		/// Optional map containing area specific information: key – unique name of the specific property; value – value of that property
		/// </summary>
		private IDictionary<string,System.String> _tags;
		public virtual Schema Schema
		{
			get
			{
				return AggrArea._SCHEMA;
			}
		}
		/// <summary>
		/// Optional list of locations, creating an edge between every consecutive location in the list. An additional edge is created between the last location in the list and the first location in the list, closing of the area. The smallest shape created by this boundary defines the area
		/// </summary>
		public IList<eu.driver.model.sim.support.Location> boundary
		{
			get
			{
				return this._boundary;
			}
			set
			{
				this._boundary = value;
			}
		}
		/// <summary>
		/// Optional name of the area
		/// </summary>
		public string name
		{
			get
			{
				return this._name;
			}
			set
			{
				this._name = value;
			}
		}
		/// <summary>
		/// Optional map containing area specific information: key – unique name of the specific property; value – value of that property
		/// </summary>
		public IDictionary<string,System.String> tags
		{
			get
			{
				return this._tags;
			}
			set
			{
				this._tags = value;
			}
		}
		public virtual object Get(int fieldPos)
		{
			switch (fieldPos)
			{
			case 0: return this.boundary;
			case 1: return this.name;
			case 2: return this.tags;
			default: throw new AvroRuntimeException("Bad index " + fieldPos + " in Get()");
			};
		}
		public virtual void Put(int fieldPos, object fieldValue)
		{
			switch (fieldPos)
			{
			case 0: this.boundary = (IList<eu.driver.model.sim.support.Location>)fieldValue; break;
			case 1: this.name = (System.String)fieldValue; break;
			case 2: this.tags = (IDictionary<string,System.String>)fieldValue; break;
			default: throw new AvroRuntimeException("Bad index " + fieldPos + " in Put()");
			};
		}
	}
}
